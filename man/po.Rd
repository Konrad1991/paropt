% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{po}
\alias{po}
\title{Optimize parameters of ode-systems}
\usage{
po(
  integration_times,
  ode_sys,
  relative_tolerance,
  absolute_tolerances,
  lower,
  upper,
  states,
  npop,
  ngen,
  error,
  solvertype
)
}
\arguments{
\item{integration_times}{a vector containing the time course to solve the ode-system (see Details for more Information)}

\item{ode_sys}{the ode-system which will be integrated by the solver (see Details for more Information). Currently the ode system has to be converted using the function 'convert'.}

\item{relative_tolerance}{a number defining the relative tolerance used by the ode-solver.}

\item{absolute_tolerances}{a vector containing the absolute tolerance(s) for each state used by the ode-solver.}

\item{lower}{a data.frame containing the lower bounds for the parameters (see Details for more Information).}

\item{upper}{a data.frame containing the upper bounds for the parameters (see Details for more Information).}

\item{states}{a data.frame containing the predetermined course of the states (see Details for more Information).}

\item{npop}{a number defining the number of particles used by the Particle Swarm Optimizer.}

\item{ngen}{a number defining the number of generations the Particle Swarm Optimizer (PSO) should run.}

\item{error}{a number defining a sufficient small error. When the PSO reach this value optimization is stopped.}

\item{solvertype}{a string defining the type of solver which should be used (bdf, ADAMS, ERK or ARK. see Details for more Information).}
}
\description{
Optimize parameters used in an ode equation in order to match values defined in the state-data.frame
}
\details{
The vector containing the time course to solve the ode-system should contain
the same entries as the time vector in the state-data.frame (it can be also be a different variable instead of time).

The ode system should be of type Rcpp::XPtr<OS>. The OS is predefined in the package.
The function should possess the following signature: int ode(double &time, std::vector<double> &parameter, std::vector<double> &states).
The first entry defines the time point when the function is called.
The second argument defines the parameter which should be optimized. There exist two different types of parameters.
Parameters can be either constant or variabel. In order to calculate a variable parameter at a specific timepoint the Catmull-Rom-Spline is used.
This vector contains the already interpolated parameters at the specific time-point, in the same order as defined in the data.frames containing the lower- and upper-boundaries.
The last argument is a vector containing the states in the same order as defined in the data.frame containing the state-information.
Thus, it is obligatory that the state-derivates in the ode-system are in the same order defined as in the data.frame.
Within the function the new states have to be saved in the states-vector.
Please be aware that when using the approach with the Rcpp::XPtr the optimization is run in parallel. Thus, the function has to be thread-safe (among other things don't use any R Code)!

For constant parameters use only the first row (below the headers) if other parameters are variable use “NA“ in the following rows for the constant parameters.

For variable parameters at least four points are needed. If a variable parameter is not available at every time point use “NA“ instead.

The two data.frames containg lower and upper-boundaries need the parameter in the same order.

The data.frame containing the state information should hold the time course in the first column.
The header-name time is compulsory. The following columns contain the states. Take care that the states are in the same order defined in the ode system.
If a state is not available use “NA“. This is possible for every time points except the first one.
The ode solver need a start value for each state which is extracted from the first row of this file (below the headers).

The error between the solver output and the measured states is the sum of the absolute differences divided by the number of time points.
It is crucial that the states are in the same order in the text file cointaining the state-information and in the ode-system to compare the states correctly!

For solving the ode system the SUNDIALS Software is used (https://computing.llnl.gov/projects/sundials).
The last argument defines the solver-type which is used during optimization:
“bdf“,  “ADAMS“, “ERK“ or “ARK“. bdf = Backward Differentiation Formulas, ADAMS = Adams-Moulton, ERK = explicite Runge-Kutta and ARK = implicite Runge-Kutta.
All solvers are used in the NORMAL-Step method in a for-loop using the time-points defined in the text-file containing the states as output-points.
The bdf- and ARK-Solver use the SUNLinSol_Dense as linear solver. Notably here is that for the ARK-Solver the ode system is fully implicit solved (not only part of it).
}
\examples{
\dontrun{
library(paropt)
# slow
ode <- function(t, parameter, y, ydot) {

  a = parameter[1]
  b = parameter[2]
  c = parameter[3]
  d = parameter[4]

  predator = y[1]
  prey = y[2]

  ydot[1] = predator*prey*c - predator*d
  ydot[2] = prey*a - prey*predator*b
}

# fast (but use it carefully)
ode <- function(t, parameter, y, ydot) {

  a_db = at(parameter, 1)
  b_db = at(parameter, 2)
  c_db = at(parameter, 3)
  d_db = at(parameter, 4)

  predator_db = at(y,1)
  prey_db = at(y, 2)

  ydot[1] = predator_db*prey_db*c_db - predator_db*d_db
  ydot[2] = prey_db*a_db - prey_db*predator_db*b_db
}

# compile
r <- paropt::convert(ode, verbose = TRUE)

path <- system.file("examples", package = "paropt")
states <- read.table(paste(path,"/states_LV.txt", sep = ""), header = TRUE)

# parameter
lb <- data.frame(time = 0, a = 0.8, b = 0.3, c = 0.09, d = 0.09)
ub <- data.frame(time = 0, a = 1.3, b = 0.7, c = 0.4, d = 0.7)

# Optimizing
set.seed(1)
df <- paropt::po(integration_times = states$time, ode_sys = r(),
                     relative_tolerance = 1e-6, absolute_tolerances = c(1e-8, 1e-8),
                     lower = lb, upper = ub, states = states,
                     npop = 40, ngen = 1000, error = 0.0001, solvertype = "bdf")

par(mfrow = c(2,1))
plot(states$time, df$States[,1], pch = 19,
type = 'l', ylab = "predator", xlab = "time", ylim = c(0, 30))
points(states$time, states$n1, pch = 19, col = "darkred", type = 'p')
legend(80, 30, legend=c("in silico", "measured"),
       col=c("black", "darkred"), lty=1, cex=0.8)
plot(states$time, df$States[,2], pch = 19, type = 'l',
ylab = "prey", xlab = "time", ylim = c(0, 65))
points(states$time, states$n2, pch = 19, col = "darkred", type = 'p')
legend(80, 60, legend=c("in silico", "measured"),
       col=c("black", "darkred"), lty=1, cex=0.8)
}
}
