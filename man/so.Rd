% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{so}
\alias{so}
\title{Solves ode-system and compare result to measured states}
\usage{
so(
  integration_times,
  fctptr,
  relative_tolerance,
  absolute_tolerances,
  start,
  states,
  solvertype
)
}
\arguments{
\item{integration_times}{a vector containing the time course to solve the ode-system (see Details for more Information)}

\item{fctptr}{is a pointer to the ode-system which will be integrated by the solver (see Details for more Information).}

\item{relative_tolerance}{a number defining the relative tolerance used by the ode-solver.}

\item{absolute_tolerances}{a vector containing the absolute tolerance(s) for each state used by the ode-solver.}

\item{start}{a data.frame containing a parameter-set (see Details for more Information).}

\item{states}{a data.frame containing the predetermined course of the states (see Details for more Information).}

\item{solvertype}{a string defining the type of solver which should be used (bdf, ADAMS, ERK or ARK. see Details for more Information).}
}
\description{
Solves ode-system and compare result to measured states
}
\details{
The vector containing the time course to solve the ode-system should contain
the same entries as the time vector in the state-data.frame (it can be also be a different variable instead of time).

The ode system should be of type Rcpp::XPtr<OS2>. The OS2 is predefined in the package.
The function should pOS2sess the following signature: int ode(double &time, std::vector<double> &parameter, std::vector<double> &states).
The first entry defines the time point when the function is called.
The second argument defines the parameter which should be optimized. There exist two different types of parameters.
Parameters can be either constant or variabel. In order to calculate a variable parameter at a specific timepoint the Catmull-Rom-Spline is used.
This vector contains the already interpolated parameters at the specific time-point, in the same order as defined in the data.frames containing the lower- and upper-boundaries.
The last argument is a vector containing the states in the same order as defined in the data.frame containing the state-information.
Thus, it is obligatory that the state-derivates in the ode-system are in the same order defined as in the data.frame.
Within the function the new states have to be saved in the states-vector.

For constant parameters use only the first row (below the headers) if other parameters are variable use “NA“ in the following rows for the constant parameters.

For variable parameters at least four points are needed. If a variable parameter is not available at every time point use “NA“ instead.

The data.frame containing the state information should hold the time course in the first column.
The header-name time is compulsory. The following columns contain the states. Take care that the states are in the same order defined in the ode system.
If a state is not available use “NA“. This is pOS2sible for every time points except the first one.
The ode solver need a start value for each state which is extracted from the first row of this file (below the headers).

The error between the solver output and the measured states is the sum of the absolute differences divided by the number of time points.
It is crucial that the states are in the same order in the text file cointaining the state-information and in the ode-system to compare the states correctly!

For solving the ode system the SUNDIALS Software is used (https://computing.llnl.gov/projects/sundials).
The last argument defines the solver-type which is used during optimization:
“bdf“,  “ADAMS“, “ERK“ or “ARK“. bdf = Backward Differentiation Formulas, ADAMS = Adams-Moulton, ERK = explicite Runge-Kutta and ARK = implicite Runge-Kutta.
All solvers are used in the NORMAL-Step method in a for-loop using the time-points defined in the text-file containing the states as output-points.
The bdf- and ARK-Solver use the SUNLinSol_Dense as linear solver. Notably here is that for the ARK-Solver the ode system is fully implicit solved (not only part of it).
}
\examples{
\dontrun{
library(paropt)
# slow
ode <- function(t, parameter, y, ydot) {

  a = parameter[1]
  b = parameter[2]
  c = parameter[3]
  d = parameter[4]

  predator = y[1]
  prey = y[2]

  ydot[1] = predator*prey*c - predator*d
  ydot[2] = prey*a - prey*predator*b
}

# fast (but use it carefully)
ode <- function(t, parameter, y, ydot) {

  a_db = at(parameter, 1)
  b_db = at(parameter, 2)
  c_db = at(parameter, 3)
  d_db = at(parameter, 4)

  predator_db = at(y,1)
  prey_db = at(y, 2)

  ydot[1] = predator_db*prey_db*c_db - predator_db*d_db
  ydot[2] = prey_db*a_db - prey_db*predator_db*b_db
}

# compile
r <- paropt::convert(ode, verbose = TRUE)

path <- system.file("examples", package = "paropt")
states <- read.table(paste(path,"/states_LV.txt", sep = ""), header = TRUE)

# Solve ode-system
start <- data.frame(time = 0, a = 1.1, b = 0.4, c = 0.1, d = 0.4)
df <- paropt::so(integration_times = states$time, fctptr = r(),
                              relative_tolerance = 1e-6, absolute_tolerances = c(1e-8, 1e-8),
                              start = start, states = states, solvertype = "bdf")

par(mfrow = c(2,1))
plot(states$time, states$n1, pch = 19, col = "darkred", type = 'p')
points(states$time, df$`in silico states`[,1], pch = 12, col = "black", type = 'l')
legend(80, 30, legend=c("in silico", "measured"),
       col=c("black", "darkred"), lty=1, cex=0.8)
plot(states$time, states$n2, pch = 19, col = "darkred", type = 'p')
points(states$time, df$`in silico states`[,2], pch = 12, col = "black", type = 'l')
legend(80, 60, legend=c("in silico", "measured"),
       col=c("black", "darkred"), lty=1, cex=0.8)
}
}
